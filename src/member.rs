//! Definitions for [`Member`]s, the main performers in a [`Battle`](crate::battle::Battle).

use crate::equipment::Equipment;

/// Fighting entity of a [`Team`](crate::team::Team).
pub trait Member: core::fmt::Debug + Clone + PartialEq + Eq {
    type Statistics: Statistics;
    type Properties: Properties;
    type Equipment: Equipment<Properties = Self::Properties>;

    /// Returns this [`Member`]'s name.
    fn name(&self) -> &str;

    /// Returns a reference to this [`Member`]'s statistics.
    fn statistics(&self) -> &Self::Statistics;

    /// Returns a reference to this [`Member`]'s properties.
    fn member_properties(&self) -> &Self::Properties;

    /// Returns a mutable reference to this [`Member`]'s properties.
    fn member_properties_mut(&mut self) -> &mut Self::Properties;

    /// Returns a reference to this [`Member`]'s equipment struct.
    fn equipment(&self) -> &Self::Equipment;

    /// Returns the [`Properties`] associated with this [`Member`] after *all* standard property calculations.
    ///
    /// # Notes
    ///
    /// This includes the sum of property values generated by equipped gear.
    ///
    /// This function should not be reimplemented under normal circumstances.
    fn final_properties(&self) -> Self::Properties {
        self.member_properties()
            .sum_properties(&self.equipment().associated_properties())
    }

    // `Properties` and `Statistics` function escalation (to access them directly via `Member` with additional information).

    /// Returns this [`Member`]'s current health.
    ///
    /// # Notes
    ///
    /// This is a blanket implementation over [`Properties::health()`].
    fn health(&self) -> u64 {
        self.member_properties().health()
    }

    /// Inflict direct damage to this [`Member`]'s health.
    ///
    /// # Notes
    ///
    /// This is a blanket implementation over [`Properties::damage()`].
    fn damage(&mut self, damage: u64) {
        self.member_properties_mut().damage(damage);

        log::info!(
            "Member {} takes {} damage! Health: {}/{}",
            self.name(),
            damage,
            self.member_properties().health(),
            self.statistics().reference_health(),
        );
    }
}

/// Unmutable statistics associated with a specific [`Member`].
///
/// A member's intrinsic characteristics should be defined here and never modified.
///
/// # Notes
///
/// Use [`Properties`] to keep track and calculate modifiers on these statistics.
pub trait Statistics: core::fmt::Debug + Clone + PartialEq + Eq {
    /// Amount of health to compare the "current" amount to.
    ///
    /// This is useful for UIs, game logic or general info. Usually it's supposed to be the "max" health, or some similar value.
    fn reference_health(&self) -> u64;

    /// Attack value associated to a [`Member`].
    ///
    /// This attack value is supposed to be the "base" attack deeply associated with a member's statistics.
    fn base_attack(&self) -> u64;
}

/// Properties of a [`Member`] that can change during a match.
///
/// Most commonly, a struct that implements this trait should keep track the current health points and additional multipliers.
pub trait Properties: core::fmt::Debug + Clone + PartialEq + Eq {
    /// Apply some changes to the property values based on a different property object.
    ///
    /// Have a look at [`Properties::sum_properties()`] to understand how this should work and see the default behaviour.
    ///
    /// # Notes
    ///
    /// In most cases, the default implementation should not be reimplemented. Instead, it's better to reimplement the logic of [`Properties::sum_properties()`].
    fn apply_properties(&mut self, rhs: &Self) {
        *self = self.sum_properties(rhs);
    }

    /// Returns the "sum" of property values with a different [`Properties`] object.
    ///
    /// # Notes
    ///
    /// How the "sum" should be calculated depends vastly on the type of properties stored in the struct. For example:
    /// - If the property is supposed to be immutable, the changes might have to be ignored.
    /// - If a property is a scalar value in absolute terms, the property value might be summed or subtracted from the starting value.
    /// - If a property is a multiplier, the property value might be multiplied or divided from the starting value.
    ///
    /// Regardless of suggestions, this is not a binding contract and the user may decide to implement the summation however they see fit.
    ///
    /// The default implementation returns an unmodified clone of the value stored in `self`.
    #[allow(unused_variables)]
    fn sum_properties(&self, rhs: &Self) -> Self {
        self.clone()
    }

    fn health(&self) -> u64;
    fn health_mut(&mut self) -> &mut u64;

    /// Attack value used to damage foes.
    ///
    /// This attack value shouldn't be the "base" attack, but the value actually used to inflict damage after all needed
    /// calculations are applied (like statistic's boosts).
    fn attack(&self) -> u64;

    /// Auto-generate a new set of [`Properties`] from some [`Statistics`].
    // TODO: Require From<Statistics>
    /*fn from_stats(statistics: &Statistics) -> Self {
        Self {
            health: statistics.max_health,
        }
    }*/

    /// Subtract the exact amount of health points as the damage from these properties.
    ///
    /// # Notes
    ///
    /// The health subtraction saturates to 0 if the damage exceeds the current health.
    ///
    /// This function should not be reimplemented.
    fn damage(&mut self, damage: u64) {
        *self.health_mut() = self.health().saturating_sub(damage);
    }
}

/// Identifier of a member using the team index and a "relative" member index.
#[non_exhaustive]
#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct MemberIdentifier {
    pub team_id: usize,
    pub member_id: usize,
}

impl MemberIdentifier {
    /// Create a new [`MemberIdentifier`] using the member's team index and relative index.
    pub fn new(team_id: usize, member_id: usize) -> Self {
        Self { team_id, member_id }
    }

    /// Create a new [`MemberIdentifier`] that reference's to the first team's first member.
    pub fn zeroed() -> Self {
        Self {
            team_id: 0,
            member_id: 0,
        }
    }
}
